1) Create an event structure

<Event Name> extends Event
    getName: ->
        return <Event Name>

2) Register an event listener

	handleAnEvent1: (asMyEvent) ->
		# ... <Do things here>

	handleAnEvent2: (asMyEvent) ->
		# ... <Do things here>

		# Cancel event?
		asMyEvent.setCancelled()

	# Add a listener for the event "<Event Name" that points to handleAnEvent2, with the priority Highest
	# that doesn't get executed if the event was cancelled previusly
    asEventManager.addEvent("<Event Name>", handleAnEvent2, EventPriority.Highest, true)

	# Add a listener for the event "<Event Name" that points to handleAnEvent1, with the priority Normal
	# that gets executes even if the event was cancelled
    asEventManager.addEvent("<Event Name>", handleAnEvent1)

3) Emit an event synchronized
	
	# One way to execute
	asTheEvent = asEventManager.emitEvent(new MyEventName)
	if (asTheEvent.isCancelled)
		....
	else
		....

	# Another way to execute
	asTheEvent = new MyEventName
	asEventManager.emitEvent(new MyEventName)
	if (asTheEvent.isCancelled)
		doSomething
	else
		doElse

	# Or even use a completation handler
	asEventManager.emitEvent(new MyEventName, (asEvent) -> if (asEvent.isCancelled) doSomething else doElse)
	asEventManager.emitEvent(new MyEventName, handleLastFunctionHere)

4) Emit an event asynchronized (Execute by another thread)

	asEventManager.emitAsyncEvent(new MyEventName)
	asEventManager.emitAsyncEvent(new MyEventName, (asEvent) -> handleThing(asEvent))
	asEventManager.emitAsyncEvent(new MyEventName, handleLastFunctionHere)


5) Remove an event
	
	asEventManager.removeEvent("<Event Name>", handleAnEvent2, EventPriority.Highest)
	asEventManager.removeEvent("<Event Name>", handleAnEvent1)

6) Remove all events

	asEventManager.removeAllEvent()
